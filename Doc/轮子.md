### 罗博造造——轮子
```mermaid
graph TD
A[每帧Update] --> B1(计算物理参数)
A[每帧Update] --> B2(设值给引擎)
B1 --> C{车有过变更 : 调过SetUpdateCachedValuesRequired}
C -->|是| D[更新一些每帧不变的参数 : UpdateAvgValues,UpdateComDistanceFactor,UpdateAntiRollNodes]
D --> E
C -->|否| E[每帧更新逻辑]
E --> F[UpdateRatios : 设置每个轮子当前的速度,是否后退]
F --> G[ApplySteering : 求每个轮子的currentSteeringAngle, 速度越快, 最大转向角越小]
G --> H[HandleForwardInput : groundedMotorizedParts > 0的时候, <br>计算前进或后退的驱动力, 存在pendingForce和pendingVelocityChangeForce]
H --> I{着地轮子数量>0, 速度>0.2}
I --> |是| J[防滚力ApplyAntiRollForce和防滑力ApplyAntiSlipForce]
I --> |否| K[ApplyVerticalDampingForce防止纵向翻滚]
J --> K
K --> L[对于每一个轮子: <br>ApplyFriction设置Unity轮子的参数, <br> UpdateForcePoint确定每个轮子的施力点 <br> ApplyForces把前面得到的pendingForce和pendingVelocityChangeForce给车]
```
    其中：ApplyAntiSlipForce防滑力的计算方法如下：
    0、 前后轮，分两组
    1、 计算每组轮子的平局施力点forcePoint和sidewaysSlip向量之和val4
    2、 float num = Mathf.Clamp01((float)(node.numGroundedWheelsComponent.groundedParts - 1) / 3f);
    3、 Vector3 force = -val4 * (num / 轮子数);
    4、 num的计算比较有意思，可以参考一下
    
    




